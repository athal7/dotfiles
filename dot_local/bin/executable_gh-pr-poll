#!/usr/bin/env bash
#
# gh-pr-poll - Check GitHub for PR work and trigger OpenCode agents
#
# Checks for:
#   - PRs where your review is requested → spawns review agent
#   - Your PRs with changes requested → spawns dev agent
#
# Uses gh CLI to check GitHub, only calls opencode when there's work.
# For PRs needing changes, creates a git worktree as a sibling directory
# (e.g., repo-pr-123) to avoid conflicts with your main working directory.
# Also sets up devcontainer.local.json with unique ports for concurrent
# devcontainer usage. Automatically cleans up worktrees when PRs are merged
# or closed.
#
# Usage:
#   gh-pr-poll              # Run once
#   gh-pr-poll --dry-run    # Show what would happen
#   gh-pr-poll --sessions   # List active tmux sessions
#
# Environment:
#   GH_PR_POLL_OPENCODE_DIR  Override directory for opencode sessions (default: repo directory)
#
# To run automatically every 2 minutes:
#   launchctl load ~/Library/LaunchAgents/com.gh-pr-poll.plist
#

set -euo pipefail

STATE_DIR="${HOME}/.local/share/gh-pr-poll"
STATE_FILE="${STATE_DIR}/state.json"
OPENCODE_DIR="${GH_PR_POLL_OPENCODE_DIR:-}"
DRY_RUN=false

mkdir -p "$STATE_DIR"
[[ -f "$STATE_FILE" ]] || echo '{"reviews":[],"feedback":[]}' > "$STATE_FILE"

log() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"; }

# Create a git worktree for PR work (preferred over clone for disk efficiency)
# Returns the path to the worktree directory
create_pr_worktree() {
  local repo_full="$1" num="$2" branch="$3"
  local repo=$(echo "$repo_full" | cut -d/ -f2)
  
  # Find the main repo directory
  local main_repo=""
  local base_dir="${HOME}/Documents/GitHub"
  for dir in "${HOME}/Documents/GitHub" "${HOME}/Projects" "${HOME}/code" "${HOME}/src"; do
    if [[ -d "${dir}/${repo}/.git" ]] || [[ -f "${dir}/${repo}/.git" ]]; then
      # Check if it's the main repo (not a worktree itself)
      if [[ -d "${dir}/${repo}/.git" ]]; then
        main_repo="${dir}/${repo}"
        base_dir="$dir"
        break
      fi
    fi
  done
  
  local pr_dir="${base_dir}/${repo}-pr-${num}"
  
  # If worktree already exists, just update it
  if [[ -d "$pr_dir" ]] && [[ -f "$pr_dir/.git" ]]; then
    cd "$pr_dir"
    git fetch origin "$branch" 2>/dev/null || true
    git checkout "$branch" 2>/dev/null || git checkout -b "$branch" "origin/$branch" 2>/dev/null || true
    git pull origin "$branch" 2>/dev/null || true
    echo "$pr_dir"
    return
  fi
  
  # If main repo exists, create worktree (preferred)
  if [[ -n "$main_repo" ]]; then
    log "  Creating worktree for PR #$num at $pr_dir"
    cd "$main_repo"
    git fetch origin "$branch" 2>/dev/null || true
    if git worktree add "$pr_dir" "$branch" 2>/dev/null || \
       git worktree add "$pr_dir" -b "$branch" "origin/$branch" 2>/dev/null; then
      # Set up devcontainer port override to avoid conflicts
      setup_devcontainer_port "$pr_dir" "$repo" "$num"
      echo "$pr_dir"
      return
    fi
  fi
  
  # Fallback: clone if no main repo found
  log "  Cloning PR #$num to $pr_dir (no main repo found for worktree)"
  if gh repo clone "$repo_full" "$pr_dir" -- --branch "$branch" 2>/dev/null; then
    setup_devcontainer_port "$pr_dir" "$repo" "$num"
    echo "$pr_dir"
  else
    log "  ERROR: Failed to clone $repo_full"
    return 1
  fi
}

# Check if a port is in use (listening)
port_in_use() {
  local port="$1"
  lsof -i ":$port" -sTCP:LISTEN >/dev/null 2>&1
}

# Set up devcontainer.local.json with unique port to avoid conflicts
setup_devcontainer_port() {
  local pr_dir="$1" repo="$2" num="$3"
  local devcontainer_dir="${pr_dir}/.devcontainer"
  local local_config="${devcontainer_dir}/devcontainer.local.json"
  
  # Only if devcontainer exists and local config doesn't
  if [[ -d "$devcontainer_dir" ]] && [[ ! -f "$local_config" ]]; then
    # Collect all ports already assigned in local configs
    local -a assigned_ports=()
    local base_dir=$(dirname "$pr_dir")
    
    for config in "$base_dir"/*/.devcontainer/devcontainer.local.json; do
      if [[ -f "$config" ]]; then
        local port=$(grep -o '"runArgs".*\["-p".*"[0-9]*:' "$config" 2>/dev/null | grep -o '[0-9]*:' | tr -d ':' | head -1)
        if [[ -n "$port" ]]; then
          assigned_ports+=("$port")
        fi
      fi
    done
    
    # Find next available port starting from 3000
    local new_port=3000
    while true; do
      # Check if port is assigned in any local config
      local is_assigned=false
      for p in "${assigned_ports[@]}"; do
        if [[ "$p" == "$new_port" ]]; then
          is_assigned=true
          break
        fi
      done
      
      # Check if port is actually in use on the system
      if [[ "$is_assigned" == "false" ]] && ! port_in_use "$new_port"; then
        break
      fi
      
      new_port=$((new_port + 1))
      
      # Safety: don't scan forever
      if [[ "$new_port" -gt 3100 ]]; then
        log "  WARNING: Could not find open port in range 3000-3100"
        new_port=3000  # Fall back to default
        break
      fi
    done
    
    log "  Setting up devcontainer on port $new_port"
    
    cat > "$local_config" << EOF
{
  "name": "${repo} - PR-${num}",
  "runArgs": ["-p", "${new_port}:3000"],
  "forwardPorts": [${new_port}]
}
EOF
  fi
}

# Check if already processed
already_processed() {
  local key="$1" field="$2"
  jq -e --arg k "$key" ".${field} | index(\$k)" "$STATE_FILE" >/dev/null 2>&1
}

# Mark as processed
mark_processed() {
  local key="$1" field="$2"
  local tmp=$(mktemp)
  jq --arg k "$key" ".${field} += [\$k]" "$STATE_FILE" > "$tmp" && mv "$tmp" "$STATE_FILE"
}

# Find local repo path for a GitHub repo
find_repo() {
  local owner="$1" repo="$2"
  
  # Check common locations
  for base in "${HOME}/Documents/GitHub" "${HOME}/Projects" "${HOME}/code" "${HOME}/src"; do
    local path="${base}/${repo}"
    if [[ -d "$path/.git" ]]; then
      echo "$path"
      return
    fi
  done
}

# Clean up PR directories for merged/closed PRs
# Handles both worktrees and clones
cleanup_pr_dirs() {
  log "Cleaning up merged/closed PR directories..."
  
  for base in "${HOME}/Documents/GitHub" "${HOME}/Projects" "${HOME}/code" "${HOME}/src"; do
    [[ -d "$base" ]] || continue
    
    for pr_dir in "$base"/*-pr-[0-9]*; do
      [[ -d "$pr_dir" ]] || continue
      
      # Extract repo name and PR number from directory name
      local dirname=$(basename "$pr_dir")
      local repo=$(echo "$dirname" | sed -E 's/-pr-[0-9]+$//')
      local num=$(echo "$dirname" | sed -E 's/.*-pr-([0-9]+)$/\1/')
      
      # Get the remote URL to find owner (works for both worktrees and clones)
      local remote_url=$(git -C "$pr_dir" remote get-url origin 2>/dev/null) || continue
      local repo_full=$(echo "$remote_url" | sed -E 's|.*github.com[:/]([^/]+/[^/.]+)(\.git)?$|\1|')
      
      # Check PR state
      local pr_state=$(gh api "repos/${repo_full}/pulls/${num}" --jq '.state' 2>/dev/null) || continue
      
      if [[ "$pr_state" == "closed" ]]; then
        if [[ "$DRY_RUN" == "true" ]]; then
          log "  [DRY RUN] Would remove $pr_dir (PR #$num is closed)"
        else
          log "  Removing $pr_dir (PR #$num is closed)"
          
          # Check if it's a worktree (has .git file, not directory)
          if [[ -f "$pr_dir/.git" ]]; then
            # Find the main repo to remove worktree properly
            local main_repo="${base}/${repo}"
            if [[ -d "$main_repo/.git" ]]; then
              git -C "$main_repo" worktree remove "$pr_dir" --force 2>/dev/null || rm -rf "$pr_dir"
            else
              rm -rf "$pr_dir"
            fi
          else
            rm -rf "$pr_dir"
          fi
        fi
      fi
    done
  done
}

poll() {
  log "Checking GitHub for PR work..."
  
  local username=$(gh api user --jq '.login' 2>/dev/null) || true
  if [[ -z "$username" ]]; then
    log "ERROR: Could not get GitHub username. Is gh authenticated?"
    exit 1
  fi
  
  # 1. PRs where my review is requested
  log "Checking for PRs needing review..."
  local review_prs=$(gh api "search/issues?q=is:pr+is:open+review-requested:${username}" --jq '.items // []' 2>/dev/null || echo '[]')
  
  echo "$review_prs" | jq -c '.[]' | while read -r pr; do
    local url=$(echo "$pr" | jq -r '.html_url')
    local num=$(echo "$pr" | jq -r '.number')
    local title=$(echo "$pr" | jq -r '.title')
    local updated_at=$(echo "$pr" | jq -r '.updated_at')
    local repo_full=$(echo "$url" | sed -E 's|https://github.com/([^/]+/[^/]+)/pull/.*|\1|')
    local owner=$(echo "$repo_full" | cut -d/ -f1)
    local repo=$(echo "$repo_full" | cut -d/ -f2)
    
    # Track by url:updated_at so re-review requests trigger new sessions
    local key="${url}:${updated_at}"
    if already_processed "$key" "reviews"; then
      continue
    fi
    
    log "Found: PR #$num needs review ($repo_full)"
    
    local opencode_dir="$OPENCODE_DIR"
    if [[ -z "$opencode_dir" ]]; then
      opencode_dir=$(find_repo "$owner" "$repo")
      if [[ -z "$opencode_dir" ]]; then
        log "  Skipping: repo not found locally"
        continue
      fi
    fi
    
    local prompt="Please review this pull request:

**PR #$num: $title**
Repository: $repo_full
URL: $url

Please review the code changes and provide feedback on security, performance, and code quality. Wait for my approval before submitting the review on GitHub."

    if [[ "$DRY_RUN" == "true" ]]; then
      log "  [DRY RUN] Would start review agent in $opencode_dir"
    else
      local session_name="review-${repo}-${num}"
      log "  Starting review agent in tmux session: $session_name"
      tmux new-session -d -s "$session_name" -c "$opencode_dir" "opencode -p '$prompt' --agent review"
      mark_processed "$key" "reviews"
    fi
  done
  
  # 2. My PRs with changes requested
  log "Checking for PRs with feedback..."
  local my_prs=$(gh api "search/issues?q=is:pr+is:open+author:${username}" --jq '.items // []' 2>/dev/null || echo '[]')
  
  echo "$my_prs" | jq -c '.[]' | while read -r pr; do
    local url=$(echo "$pr" | jq -r '.html_url')
    local num=$(echo "$pr" | jq -r '.number')
    local title=$(echo "$pr" | jq -r '.title')
    local repo_full=$(echo "$url" | sed -E 's|https://github.com/([^/]+/[^/]+)/pull/.*|\1|')
    local owner=$(echo "$repo_full" | cut -d/ -f1)
    local repo=$(echo "$repo_full" | cut -d/ -f2)
    
    # Check if changes were requested
    local reviews=$(gh api "repos/${repo_full}/pulls/${num}/reviews" --jq '.' 2>/dev/null || echo '[]')
    local latest_state=$(echo "$reviews" | jq -r 'last | .state // empty')
    
    if [[ "$latest_state" != "CHANGES_REQUESTED" ]]; then
      continue
    fi
    
    local review_id=$(echo "$reviews" | jq -r 'last | .id')
    local key="${url}:${review_id}"
    
    if already_processed "$key" "feedback"; then
      continue
    fi
    
    log "Found: PR #$num has changes requested ($repo_full)"
    
    # Get the PR branch name
    local pr_branch=$(gh api "repos/${repo_full}/pulls/${num}" --jq '.head.ref' 2>/dev/null)
    if [[ -z "$pr_branch" ]]; then
      log "  Skipping: could not get PR branch"
      continue
    fi
    
    local reviewer=$(echo "$reviews" | jq -r 'last | .user.login // "reviewer"')
    local review_body=$(echo "$reviews" | jq -r 'last | .body // "(see inline comments)"')
    
    local prompt="I received feedback on my pull request that requires changes:

**PR #$num: $title**
Repository: $repo_full
URL: $url
Branch: $pr_branch

**Review from $reviewer:**
$review_body

Please read the review comments and address each piece of feedback. Wait for my approval before committing."

    # Create worktree for PR (or use override)
    local opencode_dir="$OPENCODE_DIR"
    if [[ -z "$opencode_dir" ]]; then
      opencode_dir=$(create_pr_worktree "$repo_full" "$num" "$pr_branch")
      if [[ -z "$opencode_dir" ]]; then
        continue
      fi
    fi
    if [[ "$DRY_RUN" == "true" ]]; then
      log "  [DRY RUN] Would start dev agent in $opencode_dir"
    else
      local session_name="dev-${repo}-${num}"
      log "  Starting dev agent in tmux session: $session_name"
      tmux new-session -d -s "$session_name" -c "$opencode_dir" "opencode -p '$prompt' --agent dev"
      mark_processed "$key" "feedback"
    fi
  done
  
  # 3. Clean up directories for merged/closed PRs
  cleanup_pr_dirs
  
  log "Poll complete"
}

case "${1:-}" in
  --dry-run|-n)
    DRY_RUN=true
    poll
    ;;
  --reset|-r)
    echo '{"reviews":[],"feedback":[]}' > "$STATE_FILE"
    echo "State reset"
    ;;
  --status|-s)
    echo "State file: $STATE_FILE"
    cat "$STATE_FILE" | jq .
    ;;
  --sessions|-l)
    echo "Active gh-pr-poll tmux sessions:"
    tmux list-sessions 2>/dev/null | grep -E '^(review|dev)-' || echo "  (none)"
    ;;
  --help|-h)
    echo "Usage: gh-pr-poll [--dry-run|--reset|--status|--sessions|--help]"
    echo
    echo "Checks GitHub for PR work and triggers OpenCode agents in tmux sessions."
    echo "Looks for repos in ~/Documents/GitHub, ~/Projects, ~/code, ~/src"
    echo
    echo "Options:"
    echo "  --dry-run, -n   Show what would happen without spawning agents"
    echo "  --reset, -r     Clear the state file"
    echo "  --status, -s    Show current state"
    echo "  --sessions, -l  List active tmux sessions"
    echo
    echo "Set GH_PR_POLL_OPENCODE_DIR to override the opencode session directory."
    echo
    echo "To attach to a session: tmux attach -t <session-name>"
    ;;
  *)
    poll
    ;;
esac
